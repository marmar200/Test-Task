# Метод двух указателей O(t*n)
# в этой задаче не используется дополнительный список, поэтому по памяти оптимально
# по времени, используется только два цикла один на t, другой на n итераций
# основная идея: взять отрезки размером k и считать сколько букв 'W' в каждом, после вывести минимальное

# считываем количетсво входных данных
t = int(input())
# запускаем цикл на t итераций
for i in range(t):
    # считываем входные данные
    n, k = map(int, input().split())
    line = input()

    # определяем два указателя, которые будут задавать начало и конец отрезка из строки
    first, second = 0, 0
    # заводим счетчик для подсчета количества букв 'W' в отрезке
    cnt = 0

    # заводим результатирующий счетчик, в котором будет хранится минимальное количество букв 'W' в отрезке строки
    # начальное значение возьмем максимальным
    counter_result = float('inf')
    # создаем цикл пока указатель на конец отрезка не дойдет до конца строки
    while second < n:
        # в cnt прибавляем 1 , если указатель на конец отрезка указывает на букву 'W', в противном случае прибавляем 0
        cnt += line[second] == 'W'
        # если длина отрезка , который находится между первым и вторым указателем, равна k
        if second - first + 1 == k:
            # то помещаем в результатирующий счетчик минимальное значение из рез.счетчик и счетчик
            counter_result = min(counter_result, cnt)
            # теперь нужно пододвинуть левый указатель правее на 1
            # для начала нужно вычесть 1 из счетчика, если левый указатель указывал на букву 'W'
            cnt -= line[first] == 'W'
            # сдвигаем левый указатель вправо на 1
            first += 1
        # сдвигаем правый указатель на 1
        second += 1
    # выводим минимальное количество букв 'W' в отрезке
    print(counter_result)
